# Kafka 入门

[TOC]

## 概述

Kafka 最初是 LinkedIn 的一个用于处理持续数据流的基础组件。它不只是一个能够存储数据的系统（比如传统的关系型数据库、键值存储引擎、搜索引擎或缓存系统），还是一个持续变化和不断增长的流处理系统。

现在 Kafka 已经被广泛地应用在社交网络的实时数据流处理当中，成为了下一代数据架构的基础。Kafka 经常会被拿来与现有的企业级消息系统、大数据系统（如 Hadoop）和数据集成 ETL 工具等技术作比较。

Kafka 有点像消息系统，允许发布和订阅消息流。从这点来看，它类似于ActiveMQ、RabbitMQ 或 IBM 的 MQSeries 等产品。Kafka 的特点在于它以集群的方式运行，可以**自由伸缩**，处理大量的应用程序；其次，Kafka 可以按照要求持久化数据，即提供了数据传递的保证——可复制、持久化，保留多长时间完全可以由你来决定。最后，流处理将数据处理的层次提升到了新高度；消息系统只会传递消息，而 Kafka 的流式处理能力让我们只用很少的代码就能够动态地处理派生流和数据集。



## 1 基础概念

#### 消息代理

在一个基于发布与订阅的消息系统中，数据消息的发送者不直接把消息发送给接收者，而是通过一个**消息代理 message broker** 传递消息，接收者订阅消息代理，并以特定的方式接收消息。Kafka 就是一个消息代理。

**消息代理 message broker** 是一种针对处理消息流而优化的数据库，它作为独立的中间服务运行，生产者和消费者作为客户端连接到消息代理服务，在使用消息代理的架构中主要有 3 种角色：

1. **生产者**将消息写入消息代理；生产者一般是异步架构的，当生产者发送消息时，它只会等待消息代理确认消息已经被缓存，而不等待消息被消费者处理
2. **消息代理**负责消息的存储，发送、重传等，一般会包含多个**消息队列 message queue**
3. **消费者**从消息代理接收消息并进行处理；消费者只依赖于消息代理，与生产者完全隔离

#### 消息和批次

Kafka 的数据单元被称为消息，消息类似于关系型数据库里的一个数据行或一条记录；消息由字节数组组成，当消息以一种可控的方式写入不同的分区时，会用到 key，kafka 会为 key 生成一个一致性散列值，然后使用散列值对主题分区数进行取模，为消息选取分区。这样可以保证具有相同 key 的消息总是被写到相同的分区上。

如果每一个消息都单独发送，会导致大量的网络开销。为了提高效率，消息会被分批次写入Kafka；批次就是一组消息，这些消息属于同一个主题和分区；批次数据在传输时会被压缩，这样可以提升数据的传输和存储能力；单个批次的消息数量越大，单位时间内处理的消息就越多，但单个批次的传输时间就越长，因此需要在时延和吞吐量之间作出权衡。

#### 主题和分区
Kafka 的消息通过**主题 topic** 进行分类，主题就好比关系型数据库的表，或者文件系统里的目录；同一个主题可以被分为若干个**分区 partition**，一个 partition 即一个提交日志，消息以追加的方式写入 partition，然后以先入先出的顺序读取。一个 topic 一般包含多个 partition，因此无法在整个 topic 的维度保证消息的顺序，只能保证消息在单个 partition 内的顺序。

我们通常用**流 stream** 来描述 Kafka 中的数据，在一个 topic 中，无论它有多少个partition，其中的数据都被视为一个 stream。

#### 生产者和消费者

Kafka 的客户端有两种基本类型：**生产者 producer**和**消费者 consumer**。

默认情况下，producer 生产的消息会被发布到一个特定的 topic 上。消息会被均衡地分布到这个 topic 的所有 partition 上，但我们也可以指定 producer 的消息直接写到指定的 partition 上。

consumer 会订阅一个或多个 topic，并按照消息生成的顺序依次读取它们。consumer 通过检查消息的**偏移量 offset**来区
分已经读取过的消息，offset 是一种元数据，它会不断递增；在给定的 partition 中，每个消息的 offset 都是唯一的，offset 值会被保存在 Zookeeper 或 Kafka 上，这样即使 consumer 停止或重启后它的读取状态依然不会丢失。

消费者是**消费者群组 consumer group** 的一部分，也就是说可能会有多个 consumer 同时共同读取一个 topic，group 会保证每个 partition 只能被一个consumer 使用。

![consumer group](http://isocpp.github.io/message-proxy/consumer group.png)















































### 消息代理优势

1. 实现异步处理，提升处理性能

把消息处理流程使用消息代理异步化，不会阻塞生产者服务，生产者服务可以在得到处理结果之前继续执行，并提高其并发处理的能力。

2. 提高系统的可伸缩性

生产者将大量消息推送到消息代理中，消息代理可以将这些消息分发给不同的消费者，使得多个消费者并行地处理消息，当消费者负载变化时，可以很容易地对消费者服务进行水平伸缩

3. 削峰填谷

当生产者推送消息的速度比消费者处理消息的速度更快时，可以使用消息队列作为消息的缓冲，来削弱峰值流量，防止系统被短时间内的流量冲垮

4. 应用解耦

使用消息代理后，生产者和消费者即可解耦，不再需要有任何联系，也不需要受对方的影响，只要保持使用一致的消息格式即可



































