## Knuth

思路：

1. 公平的洗牌算法：对于 n 个不同的数，生成它的全排列，总共有 n! 个，**等概率**地从这些结果中选取一个；
2. 公平：对于它的全排列，每个元素都能**等概率**地出现在每一个位置；

```cpp
for (int i = n - 1; i >= 0; --i)
    swap(arr[i], arr[rand() % (i + 1)]);
```

理解：

1. 从 `i = n - 1` 递减迭代直到 `i = 0`，每次从下标 `k = [0, i]` 之间随机选取一个元素 `arr[k]`，将其与 `arr[i]`  交换；
2. 第一轮，每个元素被选中的概率都是 `1/n`；在第二轮中，前 `n-1` 个元素被选中的概率是 `1/(n-1)`，但从全局的角度来看，其实这是一个条件概率，它们被选中的概率应该是**第一轮未被选中的概率**乘以**第二轮被选中的概率**，即 `(n - 1)/n * 1/(n-1) = 1/n`；以此类推，所有元素被选中的概率都是 `1/n`。

















































