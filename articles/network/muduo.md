# 《Linux多线程服务端编程：使用 muduo C++ 网络库》读书笔记

[TOC]

## 第 1 章 线程安全的对象生命周期管理

### 创建对象

构造对象时保证线程安全的要求：

1. 不在构造函数中注册回调函数
2. 不在构造函数中把 this 指针传给跨线程的对象





### 1.7 系统地避免各种指针错误

在现代 C++ 程序中一般不会出现 delete 语句，资源（包括复杂对象本身）都是通过对象（智能指针或容器）来管理的，不需要程序员还为此操心。shared_ptr/weak_ptr 都是值语义（value semantics，即对象的拷贝与原对象无关）：他们要么是栈上的对象，要么是其他对象的直接数据成员，或是标准库容器的元素，一般不会使用





## 第 2 章 线程同步概要

线程同步的四项原则：

1. 最低限度地共享对象，减少需要同步的场合
   - 尽量不把对象暴露给别的线程
   - 如果需要暴露，优先考虑使用 immutable 对象
   - 使用同步措施来充分保护对象
2. 使用高级的并发编程构件，如 TaskQueue、Producer-Consumer Queue
3. 不得已必须使用底层同步原语 primitives 时
   - 只使用非递归的互斥器和条件变量
   - 慎用读写锁，不用信号量
4. 除了使用 atmoic 整数之外，不自己编写 lock-free 代码，也不使用内核级的同步原语

### 2.1 互斥其 mutex

互斥器保护了临界区，任意时刻最多只能有一个线程在互斥器保护的临界区内读写。

使用 mutex 的主要原则有：

1. 用 RAII 的手法封装 mutex的创建、销毁、加锁、解锁
2. 只使用不可重入/非递归的 mutex
3. 不手工调用 lock 和 unlock，将其交给栈上的 Guar 对象的构造和析构函数
4. 构造 Guard 对象时，考虑调用栈上已经持有的锁，防止因加锁顺序不同导致的死锁





## 第 3 章 多线程服务器的适用场合与常用编程模型

### 3.1 进程与线程

进程 process 和文件是操作系统里最重要的两个概念之一，每个进程都有自己独立的地址空间，多个进程能共享代码段，但不能共享数据。

线程的特点是共享地址空间，从而可以高效地共享数据。

### 3.2 单线程服务器的常用编程模型

### 3.5 必须用单线程的场合

有两种场合必须使用单线程

1. 程序可能会 fork(2)
2. 限制程序的 CPU 占用率







































## 第 6 章 muduo 网络库

### 6.1

### 6.6 详解muduo 多线程模型

#### 常见的并发网络服务程序设计方案

![常见的并发网络服务程序设计方案](./resource/常见的并发网络服务程序设计方案.png)

1. 交互服务器（方案0）
   - interactive 服务器，一次服务一个客户端
   - 网络框架，IO，业务逻辑捆绑在一起
   
2. 阻塞式网络编程（方案1~4）

   - process-per-connection， thread-per-connection
   - 适用于计算时间远大于创建进程/线程的开销的任务，适合长连接，伸缩性较差
   - 阻塞式网络编程，控制线程（thread of control）阻塞在 read() 上，但 TCP 全双工协议需要同时支持 read() 和 write() 操作，有两种解决方案：（1）使用两个线程/进程分别负责读写；（2）使用 IO Multiplexing 来复用线程，即 select/poll/epoll/kqueue 等多路选择器，让一个控制线程具备处理多个连接的能力
   
3. reactor 模式（方案5 ~ 11）

   - reactor 的意义在于将消息（IO 事件）分发到用户提供的处理函数，并保持网络部分的通用代码不变，独立于用户的业务逻辑
- Reactor 事件循环所在的线程叫 IO 线程；没有事件时，IO 线程等待在 select/poll/epoll_wait 等函数上；事件到达后由网络库代码处理 IO 线程
   - ![reactor](./resource/reactor.png)
   - 
   -  



















































































